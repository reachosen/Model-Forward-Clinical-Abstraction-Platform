        if (signalGroups.length < 3) {
             errors.push(`? CRITICAL: Plan has too few signal groups (${signalGroups.length}), expected around ${expectedGroups.length}`);
        }
    } else {
        // Legacy Fallback: Allow 4-6 groups (Treat 5 as Max/Target, not strict Quota)
        if (signalGroups.length < 4 || signalGroups.length > 6) {
          errors.push(`? CRITICAL: Expected 4-5 signal groups, found ${signalGroups.length}`);
        }
    }

    let totalSignals = 0;
    signalGroups.forEach(group => {
      const signalCount = group.signals?.length || 0;
      totalSignals += signalCount;

      // Relaxed Rule: Allow groups with < 5 signals. Only warn if 0 signals.
      if (signalCount === 0) {
        warnings.push(`?? Group ${group.group_id} has 0 signals (verify clinical sufficiency)`);
      }

      group.signals?.forEach((signal: any, idx: number) => {
        if (!signal.id) errors.push(`? CRITICAL: Signal ${group.group_id}[${idx}] missing id`);
        if (!signal.evidence_type) errors.push(`? CRITICAL: Signal ${signal.id || idx} missing evidence_type`);
      });
    });

    if (totalSignals === 0) {
       errors.push('? CRITICAL: Plan has 0 total signals across all groups');
    }

    return {
      passed: errors.length === 0,
      errors,
      warnings,
      metadata: {
        tier1_checks: errors.length === 0 ? 'PASS' : 'FAIL',
        tier2_checks: warnings.length === 0 ? 'PASS' : 'WARN',
        signal_count: this.countSignals(signalGroups),
        domain,
        archetype,
